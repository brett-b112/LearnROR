# # =====================
# # =====================
# CLASSES
# # =====================
# # =====================


# Module => Mixin inheritance
# Allows us to defien a module that can beused by other classes through the include method
module Speak
  def speak(sound)
    puts sound
  end
end

class GoodDog
  include Speak
end

class HumanBeing
  include Speak
end

sparky = GoodDog.new
sparky.speak("Arf!")        # => Arf!
bob = HumanBeing.new
bob.speak("Hello!")         # => Hello!

GoodDog.ancestors 

=>

GoodDog
Speak
Object
Kernel
BasicObject


# # =====================
# # =====================
# GETTERS AND SETTERS
# # =====================
# # =====================
#

# Viking Class below uses #Intialize method and @instance variables
 class Viking
    def initialize(name, age, health, strength)
        @name = name
        @age = age
        @health = health
        @strength = strength
    end
end

> oleg = Viking.new("Oleg", 19, 100, 8)
=> #<Viking:0x007ffc0597bae0>

# Health Getter Method that returns health instance variable of oleg instance of Viking class
def health
    @health
end

> oleg.health
=> 87


#Setter of health method
def health=(new_health)
    @health = new_health
end

# attr_accessor isn’t magical, it just uses Ruby’s ability to create methods from within your script (part of "metaprogramming") to set up #name and #name=(new_name) and #age and #age=(new_age) etc.
# attr_accessor creates the gettr and settr methods for the instance variales
class Viking
    attr_accessor :name, :age, :health, :strength
    # codecodecode
end



# Reader 
attr_reader
#
# Writer 
attr_writer



# Instance var references, if you omit the @ sign you MUST retain health or ruby will assume you are instantiating a new health variable
self.value
@value

# @@ Is a class variable that is shared among all instances of that class

# In this example, we assume that all Vikings start with the same health, so we don’t make it a parameter you can pass in:

class Viking
    @@starting_health
    def initialize(name, age, strength)
        @health = @@starting_health
        # ...other stuff
    end
end

# You can define class methods by doing self.example_class_methor or use the classes name i.e. Viking.example_Class_method

# =========== TWO Methods for creating classes
#
# Factory Class
# The first case is called a factory method, and is designed to save you from having to keep passing a bunch of parameters manually to your #initialize method:

class Viking
    def initialize(name, health, age, strength)
        #... set variables
    end
    def self.create_warrior(name)
        age = rand * 20 + 15   # remember, rand gives a random 0 to 1
        health = [age * 5, 120].min
        strength = [age / 2, 10].min
        Viking.new(name, health, age, strength)  # returned
    end
end

> sten = Viking.create_warrior("Sten")
=> #<Viking:0x007ffc05a79848 @age=21.38812052620

# Quick Basics
# ========
* Classes are useful to use when you want to give methods to your data or have multiple instances of your data
* Class methods have access to other class methods and class variables but don’t have access to instance methods or instance variables
* Instance methods can call other instance methods, instance variables, class methods, or class variables
* If you’re thinking that class variables seem pretty similar to constants, they are only similar in that all instances have access to them. If you’ve got something that will never, CAN never change, use a constant. If you might ever change it, stick with a class variable. At the very least, it makes your code much more legible.


# # =====================
# # =====================
# INHERITANCE & SCOPE
# # =====================
# # =====================
In Ruby a class can only have one parent
class Viking < Person # => Viking extends Person


Calling #super let's you immediately access the superclasses equivalent function for overloading

# Here we can see that heal would be completed 2 times from the parent class 'Person'
def heal
        2.times { super }
        puts "Ready for battle!"
    end

# Can use within the main class as well
class Viking < Person
    def initialize(name, health, age, strength, weapon)
        super(name, health, age, strength)
        @weapon = weapon
    end
end

# Tabbing gives scope for a variable in Ruby, available in all downstream scopes
#

# Private => Makes method only callable by other methods within the class OF THAT INSTANCE
# This can be anything that you want to be conditional => i.e. die if he loses all his hp but not call .die
class Viking < Person
    ...
    def take_damage(damage)
        @health -= damage
        die if @health <= 0
    end
    private
      def die
          puts "#{self.name} has been killed :("
          self.dead = true    # assume we've defined a `dead` instance variable
      end
end

> oleg = Viking.create_warrior("Oleg")
> oleg.die
NoMethodError: private method `die' called for #<Viking:0x007ffd4c041e50>
> oleg.take_damage(200)
Oleg has been killed :(
=> true


#PROTECTED 
## protected provides most of the privacy of private but lets the methods inside ALL instances of the same class or its descendents also access it
#


# # =====================
# # =====================
# Composition
# # =====================
# HAS-A Relationship because object "has-a relationship to another object"
# Objects exist as part of the instantation of a new object often called a CONTAINER
# lifecycles of objects and container are linked
# # =====================

class Engine
  def start
    puts "Engine starting..."
  end
end

class Car
  def initialize
    @engine = Engine.new  # Engine instance is created when Car is created
  end

  def start
    @engine.start
  end
end

my_car = Car.new
my_car.start  # Engine is an integral part of Car




# # =====================
# # =====================
# Aggregation 
# # =====================
# Container does not own the objects they can exist independently
# # =====================
#



| Version                  | What It Changes       | Requires Setter? | Notes                                 |
| ------------------------ | --------------------- | ---------------- | ------------------------------------- |
| **1. Local vars**        | ❌ Nothing             | ❌ No             | Useless for updating object state     |
| **2. Instance vars (@)** | ✅ Instance variables  | ❌ No             | Direct modification, bypasses setters |
| **3. `self.attr =`**     | ✅ Uses setter methods | ✅ Yes            | Allows validations, callbacks, etc.   |

